<!DOCTYPE html>
<html lang="gu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chat - Nandigram</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        input, textarea {
            -webkit-user-select: text;
            user-select: text;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #e5ddd5;
            height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }

        .container {
            max-width: 480px;
            margin: 0 auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: white;
        }

        .header {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            color: white;
            height: 90px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 0 16px 12px 16px;
        }

        .header-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .back-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .avatar-small {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #10b981;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            background-size: cover;
            background-position: center;
        }

        .chat-info {
            flex: 1;
        }

        .chat-name {
            font-weight: 600;
            font-size: 16px;
        }

        .chat-status {
            font-size: 12px;
            opacity: 0.9;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .messages-area {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            background: #e5ddd5;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><text x="50%" y="50%" font-size="100" fill="%23d1d5db" opacity="0.1" text-anchor="middle" dominant-baseline="middle">ðŸ’¬</text></svg>');
        }

        .message {
            max-width: 70%;
            margin-bottom: 12px;
            padding: 8px 12px;
            border-radius: 8px;
            word-wrap: break-word;
            display: flex;
            flex-direction: column;
        }

        .message-sent {
            background: #dcf8c6;
            margin-left: auto;
            border-bottom-right-radius: 2px;
        }

        .message-received {
            background: white;
            margin-right: auto;
            border-bottom-left-radius: 2px;
        }

        .message-content {
            margin-bottom: 4px;
        }

        .message-time {
            font-size: 11px;
            color: #667781;
            text-align: right;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 4px;
        }

        .read-tick {
            width: 16px;
            height: 16px;
        }

        .input-area {
            background: white;
            padding: 8px;
            display: flex;
            gap: 8px;
            align-items: flex-end;
            border-top: 1px solid #e5e7eb;
        }

        .message-input {
            flex: 1;
            border: 1px solid #e5e7eb;
            border-radius: 24px;
            padding: 10px 16px;
            font-size: 15px;
            outline: none;
            max-height: 100px;
            resize: none;
        }

        .send-btn {
            width: 44px;
            height: 44px;
            background: #16a34a;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
        }

        .send-btn:active {
            background: #15803d;
        }

        .send-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .loading-messages {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #6b7280;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top-color: #16a34a;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <button class="back-btn" onclick="goBack()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                        <path d="m15 18-6-6 6-6"/>
                    </svg>
                </button>
                <div class="avatar-small" id="chatAvatar"></div>
                <div class="chat-info">
                    <div class="chat-name" id="chatName">Loading...</div>
                    <div class="chat-status" id="chatStatus"></div>
                </div>
                <div class="header-actions">
                    <button class="icon-btn" onclick="makeCall()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                            <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
                        </svg>
                    </button>
                    <button class="icon-btn" onclick="openChatInfo()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                            <line x1="4" x2="20" y1="12" y2="12"/>
                            <line x1="4" x2="20" y1="6" y2="6"/>
                            <line x1="4" x2="20" y1="18" y2="18"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <div class="messages-area" id="messagesArea">
            <div class="loading-messages" id="loadingMessages">
                <div class="spinner"></div>
                <p>Loading messages...</p>
            </div>
        </div>

        <div class="input-area">
            <textarea class="message-input" id="messageInput" placeholder="Type a message..." rows="1" onkeypress="handleKeyPress(event)" oninput="handleInput()"></textarea>
            <button class="send-btn" id="sendBtn" onclick="sendMessage()" disabled>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                    <line x1="22" x2="11" y1="2" y2="13"/>
                    <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                </svg>
            </button>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://bhmycvrbucmbbrpzeane.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJobXljdnJidWNtYmJycHplYW5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ2OTQwOTYsImV4cCI6MjA4MDI3MDA5Nn0.qQ3bw9cADG0P8hbGwx76Oeg54l-9FbRWxc92nZdSPL4';

        let supabaseClient;
        
        function initSupabase() {
            if (!supabaseClient) {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
            }
            return supabaseClient;
        }

        let currentUser = null;
        let currentChatId = null;
        let currentChatData = null;
        let messages = [];
        let messagesSubscription = null;
        let statusUpdateInterval = null;

        const urlParams = new URLSearchParams(window.location.search);
        currentChatId = urlParams.get('chat_id');

        if (!currentChatId) {
            alert('No chat selected');
            window.location.href = 'ngm_main_chat.html';
        }

        async function checkAuth() {
            const { data: { user } } = await supabaseClient.auth.getUser();
            if (!user) {
                window.location.href = 'login.html';
                return null;
            }
            currentUser = user;
            return user;
        }

        // Format last seen based on time difference - simplified without privacy settings
        function formatLastSeen(lastSeenStr, isOnline) {
            const lastSeen = new Date(lastSeenStr);
            const now = new Date();
            const diffMs = now - lastSeen;
            const diffSeconds = Math.floor(diffMs / 1000);
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            // Show "online" only if last_seen is within 60 seconds AND is_online is true
            if (isOnline === true && diffSeconds <= 60) {
                return 'online';
            }
            
            // Show actual time based on difference
            if (diffMins < 1) return 'last seen just now';
            if (diffMins === 1) return 'last seen 1 min ago';
            if (diffMins < 60) return 'last seen ' + diffMins + ' min ago';
            if (diffHours === 1) return 'last seen 1 hour ago';
            if (diffHours < 24) return 'last seen ' + diffHours + ' hours ago';
            if (diffDays === 1) return 'last seen yesterday';
            if (diffDays < 7) return 'last seen ' + diffDays + ' days ago';
            return 'last seen ' + lastSeen.toLocaleDateString();
        }

        function updateUserStatus(userData, isBlocked) {
            let statusText = '';
            if (isBlocked) {
                statusText = 'last seen a long time ago';
            } else {
                statusText = formatLastSeen(userData.last_seen, userData.is_online);
            }
            
            document.getElementById('chatStatus').textContent = statusText;
        }

        let statusSubscription = null;
        let otherUserData = null;
        let isOtherUserBlocked = false;

        function setupLiveStatusUpdates(otherUserId) {
            if (statusSubscription) {
                supabaseClient.removeChannel(statusSubscription);
            }
            
            // Clear any existing interval
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
            }

            statusSubscription = supabaseClient
                .channel('user-status:' + otherUserId)
                .on('postgres_changes', {
                    event: 'UPDATE',
                    schema: 'public',
                    table: 'ngm_users',
                    filter: 'user_id=eq.' + otherUserId
                }, payload => {
                    otherUserData = payload.new;
                    supabaseClient
                        .from('ngm_blocked_users')
                        .select('block_id')
                        .eq('user_id', otherUserId)
                        .eq('blocked_user_id', currentUser.id)
                        .maybeSingle()
                        .then(({ data }) => {
                            isOtherUserBlocked = !!data;
                            updateUserStatus(otherUserData, isOtherUserBlocked);
                        });
                })
                .subscribe();
            
            // Update status every 10 seconds to show accurate time
            statusUpdateInterval = setInterval(() => {
                if (otherUserData) {
                    updateUserStatus(otherUserData, isOtherUserBlocked);
                }
            }, 10000); // Update every 10 seconds
        }

        async function loadChatDetails() {
            try {
                const { data: chat, error: chatError } = await supabaseClient
                    .from('ngm_chats')
                    .select('*')
                    .eq('chat_id', currentChatId)
                    .single();

                if (chatError) throw chatError;

                currentChatData = chat;

                if (chat.chat_type === 'private' || chat.chat_type === 'personal') {
                    const otherUserId = chat.user1_id === currentUser.id ? chat.user2_id : chat.user1_id;
                    
                    const { data: userData, error: userError } = await supabaseClient
                        .from('ngm_users')
                        .select('full_name, username, profile_picture_url, is_online, last_seen')
                        .eq('user_id', otherUserId)
                        .single();

                    if (userError) throw userError;

                    otherUserData = userData;

                    const { data: contactData } = await supabaseClient
                        .from('ngm_contacts')
                        .select('contact_name')
                        .eq('user_id', currentUser.id)
                        .eq('contact_user_id', otherUserId)
                        .maybeSingle();

                    const { data: blockedData } = await supabaseClient
                        .from('ngm_blocked_users')
                        .select('block_id')
                        .eq('user_id', otherUserId)
                        .eq('blocked_user_id', currentUser.id)
                        .maybeSingle();

                    isOtherUserBlocked = !!blockedData;

                    const name = contactData?.contact_name || userData.full_name || userData.username || 'Unknown User';
                    document.getElementById('chatName').textContent = name;
                    
                    updateUserStatus(userData, isOtherUserBlocked);

                    if (userData.profile_picture_url) {
                        document.getElementById('chatAvatar').style.backgroundImage = "url('" + userData.profile_picture_url + "')";
                    } else {
                        document.getElementById('chatAvatar').textContent = name.charAt(0).toUpperCase();
                    }
                    
                    setupLiveStatusUpdates(otherUserId);
                } else if (chat.chat_type === 'group') {
                    const { data: groupData } = await supabaseClient
                        .from('ngm_groups')
                        .select('group_name, group_picture_url')
                        .eq('chat_id', currentChatId)
                        .single();

                    const name = groupData?.group_name || 'Group Chat';
                    document.getElementById('chatName').textContent = name;
                    document.getElementById('chatStatus').textContent = 'Group';

                    if (groupData?.group_picture_url) {
                        document.getElementById('chatAvatar').style.backgroundImage = "url('" + groupData.group_picture_url + "')";
                    } else {
                        document.getElementById('chatAvatar').textContent = name.charAt(0).toUpperCase();
                    }

                    const { count } = await supabaseClient
                        .from('ngm_chat_participants')
                        .select('*', { count: 'exact', head: true })
                        .eq('chat_id', currentChatId)
                        .eq('is_active', true);

                    document.getElementById('chatStatus').textContent = count + ' members';
                } else if (chat.chat_type === 'channel') {
                    const { data: channelData } = await supabaseClient
                        .from('ngm_channels')
                        .select('channel_name, channel_picture_url, subscriber_count')
                        .eq('chat_id', currentChatId)
                        .single();

                    const name = channelData?.channel_name || 'Channel';
                    document.getElementById('chatName').textContent = name;
                    document.getElementById('chatStatus').textContent = (channelData?.subscriber_count || 0) + ' subscribers';

                    if (channelData?.channel_picture_url) {
                        document.getElementById('chatAvatar').style.backgroundImage = "url('" + channelData.channel_picture_url + "')";
                    } else {
                        document.getElementById('chatAvatar').textContent = name.charAt(0).toUpperCase();
                    }
                }
            } catch (error) {
                console.error('Error loading chat details:', error);
                document.getElementById('chatName').textContent = 'Error loading chat';
            }
        }

        async function loadMessages() {
            try {
                const { data: msgs, error } = await supabaseClient
                    .from('ngm_messages')
                    .select('*')
                    .eq('chat_id', currentChatId)
                    .eq('is_deleted', false)
                    .order('created_at', { ascending: true });

                if (error) throw error;

                messages = msgs || [];
                
                const loadingEl = document.getElementById('loadingMessages');
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                }
                
                renderMessages();
                scrollToBottom();

                await markMessagesAsRead();

            } catch (error) {
                console.error('Error loading messages:', error);
                const loadingEl = document.getElementById('loadingMessages');
                if (loadingEl) {
                    loadingEl.innerHTML = '<p style="color: #ef4444;">Error loading messages</p>';
                }
            }
        }

        function getMessageTick(msg) {
            const singleTick = '<svg class="read-tick" width="16" height="15" viewBox="0 0 16 15" fill="#8696a0"><path d="M15.01 3.316l-.478-.372a.365.365 0 0 0-.51.063L8.666 9.879a.32.32 0 0 1-.484.033l-.358-.325a.319.319 0 0 0-.484.032l-.378.483a.418.418 0 0 0 .036.541l1.32 1.266c.143.14.361.125.484-.033l6.272-8.048a.366.366 0 0 0-.064-.512z"/></svg>';
            
            const doubleTick = '<svg class="read-tick" width="16" height="15" viewBox="0 0 16 15" fill="#8696a0"><path d="M15.01 3.316l-.478-.372a.365.365 0 0 0-.51.063L8.666 9.879a.32.32 0 0 1-.484.033l-.358-.325a.319.319 0 0 0-.484.032l-.378.483a.418.418 0 0 0 .036.541l1.32 1.266c.143.14.361.125.484-.033l6.272-8.048a.366.366 0 0 0-.064-.512zm-4.1 0l-.478-.372a.365.365 0 0 0-.51.063L4.566 9.879a.32.32 0 0 1-.484.033L1.891 7.769a.366.366 0 0 0-.515.006l-.423.433a.364.364 0 0 0 .006.514l3.258 3.185c.143.14.361.125.484-.033l6.272-8.048a.365.365 0 0 0-.063-.51z"/></svg>';
            
            const blueDoubleTick = '<svg class="read-tick" width="16" height="15" viewBox="0 0 16 15" fill="#53bdeb"><path d="M15.01 3.316l-.478-.372a.365.365 0 0 0-.51.063L8.666 9.879a.32.32 0 0 1-.484.033l-.358-.325a.319.319 0 0 0-.484.032l-.378.483a.418.418 0 0 0 .036.541l1.32 1.266c.143.14.361.125.484-.033l6.272-8.048a.366.366 0 0 0-.064-.512zm-4.1 0l-.478-.372a.365.365 0 0 0-.51.063L4.566 9.879a.32.32 0 0 1-.484.033L1.891 7.769a.366.366 0 0 0-.515.006l-.423.433a.364.364 0 0 0 .006.514l3.258 3.185c.143.14.361.125.484-.033l6.272-8.048a.365.365 0 0 0-.063-.51z"/></svg>';
            
            if (msg.is_read_by_all) {
                return blueDoubleTick;
            } else if (msg.is_delivered) {
                return doubleTick;
            } else {
                return singleTick;
            }
        }

        function renderMessages() {
            const messagesArea = document.getElementById('messagesArea');
            
            if (!messages || messages.length === 0) {
                messagesArea.innerHTML = '<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #9ca3af;"><svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="margin-bottom: 16px; opacity: 0.5;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg><p style="font-size: 16px; margin-bottom: 8px;">No messages yet</p><p style="font-size: 14px;">Start the conversation!</p></div>';
                return;
            }
            
            messagesArea.innerHTML = messages.map(msg => {
                const isSent = msg.sender_id === currentUser.id;
                const time = new Date(msg.created_at).toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit' 
                });

                return '<div class="message ' + (isSent ? 'message-sent' : 'message-received') + '"><div class="message-content">' + msg.content + '</div><div class="message-time">' + time + (isSent ? getMessageTick(msg) : '') + '</div></div>';
            }).join('');
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) return;

            try {
                const { data: newMsg, error } = await supabaseClient
                    .from('ngm_messages')
                    .insert({
                        chat_id: currentChatId,
                        sender_id: currentUser.id,
                        message_type: 'text',
                        content: message
                    })
                    .select()
                    .single();

                if (error) throw error;

                await supabaseClient
                    .from('ngm_chats')
                    .update({ last_message_at: new Date().toISOString() })
                    .eq('chat_id', currentChatId);

                input.value = '';
                input.style.height = 'auto';
                document.getElementById('sendBtn').disabled = true;

            } catch (error) {
                console.error('Error sending message:', error);
                alert('Failed to send message');
            }
        }

        async function markMessagesAsRead() {
            try {
                const unreadMsgIds = messages
                    .filter(msg => msg.sender_id !== currentUser.id)
                    .map(msg => msg.message_id);

                if (unreadMsgIds.length === 0) return;

                const { data: existingStatuses } = await supabaseClient
                    .from('ngm_message_status')
                    .select('message_id')
                    .in('message_id', unreadMsgIds)
                    .eq('user_id', currentUser.id);

                const existingMsgIds = new Set(existingStatuses?.map(s => s.message_id) || []);

                const newStatuses = unreadMsgIds
                    .filter(msgId => !existingMsgIds.has(msgId))
                    .map(msgId => ({
                        message_id: msgId,
                        user_id: currentUser.id,
                        status: 'read'
                    }));

                if (newStatuses.length > 0) {
                    await supabaseClient
                        .from('ngm_message_status')
                        .insert(newStatuses);
                }

                await supabaseClient
                    .from('ngm_chat_participants')
                    .update({ 
                        unread_count: 0,
                        last_read_message_id: messages[messages.length - 1]?.message_id 
                    })
                    .eq('chat_id', currentChatId)
                    .eq('user_id', currentUser.id);
            } catch (error) {
                console.error('Error marking messages as read:', error);
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function handleInput() {
            const input = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            
            input.style.height = 'auto';
            input.style.height = Math.min(input.scrollHeight, 100) + 'px';

            sendBtn.disabled = !input.value.trim();
        }

        function scrollToBottom() {
            const messagesArea = document.getElementById('messagesArea');
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function goBack() {
            window.location.href = 'ngm_main_chat.html';
        }

        function makeCall() {
            alert('Voice call feature coming soon!');
        }

        function openChatInfo() {
            alert('Chat info page coming soon!');
        }

        function setupRealtimeSubscription() {
            messagesSubscription = supabaseClient
                .channel('messages:' + currentChatId)
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'ngm_messages',
                    filter: 'chat_id=eq.' + currentChatId
                }, payload => {
                    console.log('New message received:', payload);
                    messages.push(payload.new);
                    renderMessages();
                    scrollToBottom();

                    if (payload.new.sender_id !== currentUser.id) {
                        markMessagesAsRead();
                    }
                })
                .on('postgres_changes', {
                    event: 'UPDATE',
                    schema: 'public',
                    table: 'ngm_messages',
                    filter: 'chat_id=eq.' + currentChatId
                }, payload => {
                    console.log('Message updated:', payload);
                    const index = messages.findIndex(m => m.message_id === payload.new.message_id);
                    if (index !== -1) {
                        messages[index] = payload.new;
                        renderMessages();
                    }
                })
                .subscribe();
        }

        window.addEventListener('DOMContentLoaded', async function() {
            initSupabase();
            const user = await checkAuth();
            if (user) {
                // Set user as online when page loads
                await supabaseClient
                    .from('ngm_users')
                    .update({ 
                        is_online: true,
                        last_seen: new Date().toISOString()
                    })
                    .eq('user_id', user.id);
                
                await loadChatDetails();
                await loadMessages();
                setupRealtimeSubscription();
                
                // Update last_seen every 30 seconds while on chat window
                statusUpdateInterval = setInterval(async () => {
                    if (currentUser) {
                        await supabaseClient
                            .from('ngm_users')
                            .update({ 
                                last_seen: new Date().toISOString()
                            })
                            .eq('user_id', currentUser.id);
                    }
                }, 30000);
            }
        });

        window.addEventListener('beforeunload', () => {
            if (messagesSubscription) {
                supabaseClient.removeChannel(messagesSubscription);
            }
            if (statusSubscription) {
                supabaseClient.removeChannel(statusSubscription);
            }
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
            }
            
            // Set user as offline when leaving page
            if (currentUser) {
                supabaseClient
                    .from('ngm_users')
                    .update({ 
                        is_online: false,
                        last_seen: new Date().toISOString()
                    })
                    .eq('user_id', currentUser.id);
            }
        });

        // Handle visibility change (when tab is hidden/shown)
        document.addEventListener('visibilitychange', async () => {
            if (currentUser) {
                if (document.hidden) {
                    // Tab is hidden - set offline
                    await supabaseClient
                        .from('ngm_users')
                        .update({ 
                            is_online: false,
                            last_seen: new Date().toISOString()
                        })
                        .eq('user_id', currentUser.id);
                } else {
                    // Tab is visible again - set online
                    await supabaseClient
                        .from('ngm_users')
                        .update({ 
                            is_online: true,
                            last_seen: new Date().toISOString()
                        })
                        .eq('user_id', currentUser.id);
                }
            }
        });
    </script>
</body>
</html>
