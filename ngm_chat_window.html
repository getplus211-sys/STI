<!DOCTYPE html>
<html lang="gu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chat - Nandigram</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        input, textarea {
            -webkit-user-select: text;
            user-select: text;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #e5ddd5;
            height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }

        .container {
            max-width: 480px;
            margin: 0 auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: white;
            position: relative;
        }

        .header {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            color: white;
            height: 90px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 0 16px 12px 16px;
            flex-shrink: 0;
        }

        .header-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .back-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .avatar-small {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #10b981;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            background-size: cover;
            background-position: center;
        }

        .chat-info {
            flex: 1;
        }

        .chat-name {
            font-weight: 600;
            font-size: 16px;
        }

        .chat-status {
            font-size: 12px;
            opacity: 0.9;
        }

        .chat-status.typing {
            color: rgba(255, 255, 255, 0.95);
            font-weight: 400;
        }

        .typing-dots {
            display: inline-block;
            position: relative;
        }

        .typing-dots span {
            animation: typingDot 1.4s infinite;
            opacity: 0.6;
        }

        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typingDot {
            0%, 60%, 100% { opacity: 0.6; }
            30% { opacity: 1; }
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .messages-area {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            background: #e5ddd5;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><text x="50%" y="50%" font-size="100" fill="%23d1d5db" opacity="0.1" text-anchor="middle" dominant-baseline="middle">üí¨</text></svg>');
            transition: flex 0.3s ease;
        }

        .messages-area.with-emoji-picker {
            flex: 1;
            max-height: calc(100vh - 90px - 64px - 350px);
        }

        .message {
            max-width: 70%;
            margin-bottom: 12px;
            padding: 8px 12px;
            border-radius: 8px;
            word-wrap: break-word;
            display: flex;
            flex-direction: column;
        }

        .message-sent {
            background: #dcf8c6;
            margin-left: auto;
            border-bottom-right-radius: 2px;
        }

        .message-received {
            background: white;
            margin-right: auto;
            border-bottom-left-radius: 2px;
        }

        .message-content {
            margin-bottom: 4px;
            white-space: pre-wrap;
        }

        .message-time {
            font-size: 11px;
            color: #667781;
            text-align: right;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 4px;
        }

        .read-tick {
            width: 16px;
            height: 16px;
        }

        .input-area {
            background: white;
            padding: 8px;
            display: flex;
            gap: 8px;
            align-items: flex-end;
            border-top: 1px solid #e5e7eb;
            flex-shrink: 0;
        }

        .emoji-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: transparent;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.2s;
        }

        .emoji-btn:hover {
            background: #f3f4f6;
        }

        .emoji-btn.active {
            background: #dcf8c6;
        }

        .emoji-picker {
            background: white;
            display: none;
            flex-direction: column;
            height: 0;
            overflow: hidden;
            z-index: 100;
            border-top: 1px solid #e5e7eb;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            flex-shrink: 0;
            transition: height 0.3s ease;
        }

        .emoji-picker.show {
            display: flex;
            height: 350px;
        }

        .emoji-categories {
            display: flex;
            border-bottom: 1px solid #e5e7eb;
            padding: 8px;
            gap: 4px;
            overflow-x: auto;
            flex-shrink: 0;
        }

        .emoji-category-btn {
            width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.2s;
        }

        .emoji-category-btn:hover {
            background: #f3f4f6;
        }

        .emoji-category-btn.active {
            background: #dcf8c6;
        }

        .emoji-search {
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
            flex-shrink: 0;
        }

        .emoji-search input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
        }

        .emoji-search input:focus {
            border-color: #16a34a;
        }

        .emoji-grid {
            padding: 8px;
            overflow-y: auto;
            flex: 1;
        }

        .emoji-section-title {
            font-size: 12px;
            color: #6b7280;
            font-weight: 600;
            padding: 8px 4px 4px 4px;
            text-transform: uppercase;
        }

        .emoji-items {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }

        .emoji-item {
            width: 40px;
            height: 40px;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .emoji-item:hover {
            background: #f3f4f6;
        }

        .emoji-item:active {
            background: #e5e7eb;
        }

        .message-input {
            flex: 1;
            border: 1px solid #e5e7eb;
            border-radius: 24px;
            padding: 10px 16px;
            font-size: 15px;
            outline: none;
            max-height: 100px;
            resize: none;
        }

        .send-btn {
            width: 44px;
            height: 44px;
            background: #16a34a;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
        }

        .send-btn:active {
            background: #15803d;
        }

        .send-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .loading-messages {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #6b7280;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top-color: #16a34a;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Keyboard toggle button */
        .keyboard-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: transparent;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.2s;
        }

        .keyboard-btn:hover {
            background: #f3f4f6;
        }

        .keyboard-btn.show {
            display: flex;
        }

        /* Unread message badge */
        .unread-badge-floating {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: #16a34a;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(22, 163, 74, 0.4);
            display: none;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            z-index: 100;
            font-size: 13px;
            font-weight: 600;
            animation: slideUp 0.3s ease-out;
        }

        .unread-badge-floating.show {
            display: flex;
        }

        .unread-badge-floating:active {
            background: #15803d;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <button class="back-btn" onclick="goBack()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                        <path d="m15 18-6-6 6-6"/>
                    </svg>
                </button>
                <div class="avatar-small" id="chatAvatar"></div>
                <div class="chat-info">
                    <div class="chat-name" id="chatName">Loading...</div>
                    <div class="chat-status" id="chatStatus"></div>
                </div>
                <div class="header-actions">
                    <button class="icon-btn" onclick="makeCall()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                            <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
                        </svg>
                    </button>
                    <button class="icon-btn" onclick="openChatInfo()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                            <line x1="4" x2="20" y1="12" y2="12"/>
                            <line x1="4" x2="20" y1="6" y2="6"/>
                            <line x1="4" x2="20" y1="18" y2="18"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <div class="messages-area" id="messagesArea">
            <div class="loading-messages" id="loadingMessages">
                <div class="spinner"></div>
                <p>Loading messages...</p>
            </div>
        </div>

        <div class="input-area">
            <button class="emoji-btn" id="emojiBtn" onclick="toggleEmojiPicker()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                    <line x1="9" x2="9.01" y1="9" y2="9"/>
                    <line x1="15" x2="15.01" y1="9" y2="9"/>
                </svg>
            </button>
            <button class="keyboard-btn" id="keyboardBtn" onclick="closeEmojiPicker()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2">
                    <rect x="2" y="4" width="20" height="16" rx="2"/>
                    <path d="M6 8h.01M10 8h.01M14 8h.01M18 8h.01M8 12h.01M12 12h.01M16 12h.01M7 16h10"/>
                </svg>
            </button>
            <textarea class="message-input" id="messageInput" placeholder="Type a message..." rows="1" oninput="handleInput()"></textarea>
            <button class="send-btn" id="sendBtn" onclick="sendMessage()" disabled>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                    <line x1="22" x2="11" y1="2" y2="13"/>
                    <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                </svg>
            </button>
        </div>

        <!-- Emoji Picker -->
        <div class="emoji-picker" id="emojiPicker">
            <div class="emoji-categories" id="emojiCategories">
                <button class="emoji-category-btn active" onclick="switchEmojiCategory('recent')" data-category="recent" title="Recent">üïí</button>
                <button class="emoji-category-btn" onclick="switchEmojiCategory('smileys')" data-category="smileys" title="Smileys & People">üòä</button>
                <button class="emoji-category-btn" onclick="switchEmojiCategory('animals')" data-category="animals" title="Animals & Nature">üê∂</button>
                <button class="emoji-category-btn" onclick="switchEmojiCategory('food')" data-category="food" title="Food & Drink">üçî</button>
                <button class="emoji-category-btn" onclick="switchEmojiCategory('activities')" data-category="activities" title="Activities">‚öΩ</button>
                <button class="emoji-category-btn" onclick="switchEmojiCategory('travel')" data-category="travel" title="Travel & Places">‚úàÔ∏è</button>
                <button class="emoji-category-btn" onclick="switchEmojiCategory('objects')" data-category="objects" title="Objects">üí°</button>
                <button class="emoji-category-btn" onclick="switchEmojiCategory('symbols')" data-category="symbols" title="Symbols">‚ù§Ô∏è</button>
                <button class="emoji-category-btn" onclick="switchEmojiCategory('flags')" data-category="flags" title="Flags">üèÅ</button>
            </div>
            <div class="emoji-search">
                <input type="text" id="emojiSearch" placeholder="Search emoji..." oninput="searchEmoji(this.value)">
            </div>
            <div class="emoji-grid" id="emojiGrid"></div>
        </div>

        <!-- Unread Messages Badge -->
        <div class="unread-badge-floating" id="unreadBadge" onclick="scrollToBottomAndRead()">
            <span id="unreadCount">0</span> new message<span id="unreadPlural">s</span>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                <path d="m18 15-6-6-6 6"/>
            </svg>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://bhmycvrbucmbbrpzeane.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJobXljdnJidWNtYmJycHplYW5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ2OTQwOTYsImV4cCI6MjA4MDI3MDA5Nn0.qQ3bw9cADG0P8hbGwx76Oeg54l-9FbRWxc92nZdSPL4';

        let supabaseClient;
        
        function initSupabase() {
            if (!supabaseClient) {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
            }
            return supabaseClient;
        }

        let currentUser = null;
        let currentChatId = null;
        let currentChatData = null;
        let messages = [];
        let messagesSubscription = null;
        let statusUpdateInterval = null;
        let typingSubscription = null;
        let typingTimeout = null;
        let isTyping = false;
        let typingCheckInterval = null;
        let recentEmojis = [];
        let currentEmojiCategory = 'recent';
        
        // Unread badge variables
        let unreadCount = 0;
        let isUserAtBottom = true;

        // Emoji data organized by categories
        const emojiData = {
            smileys: ['üòÄ','üòÉ','üòÑ','üòÅ','üòÜ','üòÖ','ü§£','üòÇ','üôÇ','üôÉ','üòâ','üòä','üòá','ü•∞','üòç','ü§©','üòò','üòó','üòö','üòô','ü•≤','üòã','üòõ','üòú','ü§™','üòù','ü§ë','ü§ó','ü§≠','ü§´','ü§î','ü§ê','ü§®','üòê','üòë','üò∂','üòè','üòí','üôÑ','üò¨','ü§•','üòå','üòî','üò™','ü§§','üò¥','üò∑','ü§í','ü§ï','ü§¢','ü§Æ','ü§ß','ü•µ','ü•∂','ü•¥','üòµ','ü§Ø','ü§†','ü•≥','ü•∏','üòé','ü§ì','üßê','üòï','üòü','üôÅ','‚òπÔ∏è','üòÆ','üòØ','üò≤','üò≥','ü•∫','üò¶','üòß','üò®','üò∞','üò•','üò¢','üò≠','üò±','üòñ','üò£','üòû','üòì','üò©','üò´','ü•±','üò§','üò°','üò†','ü§¨','üòà','üëø','üíÄ','‚ò†Ô∏è','üí©','ü§°','üëπ','üë∫','üëª','üëΩ','üëæ','ü§ñ','üò∫','üò∏','üòπ','üòª','üòº','üòΩ','üôÄ','üòø','üòæ'],
            animals: ['üê∂','üê±','üê≠','üêπ','üê∞','ü¶ä','üêª','üêº','üê®','üêØ','ü¶Å','üêÆ','üê∑','üêΩ','üê∏','üêµ','üôà','üôâ','üôä','üêí','üêî','üêß','üê¶','üê§','üê£','üê•','ü¶Ü','ü¶Ö','ü¶â','ü¶á','üê∫','üêó','üê¥','ü¶Ñ','üêù','üêõ','ü¶ã','üêå','üêû','üêú','ü¶ü','ü¶ó','üï∑Ô∏è','ü¶Ç','üê¢','üêç','ü¶é','ü¶ñ','ü¶ï','üêô','ü¶ë','ü¶ê','ü¶û','ü¶Ä','üê°','üê†','üêü','üê¨','üê≥','üêã','ü¶à','üêä','üêÖ','üêÜ','ü¶ì','ü¶ç','ü¶ß','üêò','ü¶õ','ü¶è','üê™','üê´','ü¶í','ü¶ò','üêÉ','üêÇ','üêÑ','üêé','üêñ','üêè','üêë','ü¶ô','üêê','ü¶å','üêï','üê©','ü¶Æ','üêï‚Äçü¶∫','üêà','üêì','ü¶É','ü¶ö','ü¶ú','ü¶¢','ü¶©','üïäÔ∏è','üêá','ü¶ù','ü¶®','ü¶°','ü¶¶','ü¶•','üêÅ','üêÄ','üêøÔ∏è','ü¶î'],
            food: ['üçá','üçà','üçâ','üçä','üçã','üçå','üçç','ü•≠','üçé','üçè','üçê','üçë','üçí','üçì','ü•ù','üçÖ','ü••','ü•ë','üçÜ','ü•î','ü•ï','üåΩ','üå∂Ô∏è','ü•í','ü•¨','ü•¶','üßÑ','üßÖ','üçÑ','ü•ú','üå∞','üçû','ü•ê','ü•ñ','ü•®','ü•Ø','ü•û','üßá','üßÄ','üçñ','üçó','ü•©','ü•ì','üçî','üçü','üçï','üå≠','ü•™','üåÆ','üåØ','ü•ô','üßÜ','ü•ö','üç≥','ü•ò','üç≤','ü•£','ü•ó','üçø','üßà','üßÇ','ü•´','üç±','üçò','üçô','üçö','üçõ','üçú','üçù','üç†','üç¢','üç£','üç§','üç•','ü•Æ','üç°','ü•ü','ü•†','ü•°','ü¶Ä','ü¶û','ü¶ê','ü¶ë','ü¶™','üç¶','üçß','üç®','üç©','üç™','üéÇ','üç∞','üßÅ','ü•ß','üç´','üç¨','üç≠','üçÆ','üçØ','üçº','ü•õ','‚òï','üçµ','üç∂','üçæ','üç∑','üç∏','üçπ','üç∫','üçª','ü•Ç','ü•É','ü•§','üßã','üßÉ','üßâ','üßä'],
            activities: ['‚öΩ','üèÄ','üèà','‚öæ','ü•é','üéæ','üèê','üèâ','ü•è','üé±','ü™Ä','üèì','üè∏','üèí','üèë','ü•ç','üèè','ü•Ö','‚õ≥','ü™Å','üèπ','üé£','ü§ø','ü•ä','ü•ã','üéΩ','üõπ','üõº','üõ∑','‚õ∏Ô∏è','ü•å','üéø','‚õ∑Ô∏è','üèÇ','ü™Ç','üèãÔ∏è','ü§º','ü§∏','ü§∫','ü§æ','üèåÔ∏è','üèá','üßò','üèÑ','üèä','ü§Ω','üö£','üßó','üö¥','üöµ','üé™','üé≠','üé®','üé¨','üé§','üéß','üéº','üéπ','ü•Å','üé∑','üé∫','üé∏','ü™ï','üéª','üé≤','‚ôüÔ∏è','üéØ','üé≥','üéÆ','üé∞','üß©'],
            travel: ['üöó','üöï','üöô','üöå','üöé','üèéÔ∏è','üöì','üöë','üöí','üöê','üöö','üöõ','üöú','üõ¥','üö≤','üõµ','üèçÔ∏è','üõ∫','üö®','üöî','üöç','üöò','üöñ','üö°','üö†','üöü','üöÉ','üöã','üöû','üöù','üöÑ','üöÖ','üöà','üöÇ','üöÜ','üöá','üöä','üöâ','‚úàÔ∏è','üõ´','üõ¨','üõ©Ô∏è','üí∫','üõ∞Ô∏è','üöÄ','üõ∏','üöÅ','üõ∂','‚õµ','üö§','üõ•Ô∏è','üõ≥Ô∏è','‚õ¥Ô∏è','üö¢','‚öì','‚õΩ','üöß','üö¶','üö•','üöè','üó∫Ô∏è','üóø','üóΩ','üóº','üè∞','üèØ','üèüÔ∏è','üé°','üé¢','üé†','‚õ≤','‚õ±Ô∏è','üèñÔ∏è','üèùÔ∏è','üèúÔ∏è','üåã','‚õ∞Ô∏è','üèîÔ∏è','üóª','üèïÔ∏è','‚õ∫','üè†','üè°','üèòÔ∏è','üèöÔ∏è','üèóÔ∏è','üè≠','üè¢','üè¨','üè£','üè§','üè•','üè¶','üè®','üè™','üè´','üè©','üíí','üèõÔ∏è','‚õ™','üïå','üïç','üõï','üïã','‚õ©Ô∏è','üõ§Ô∏è','üõ£Ô∏è','üóæ','üéë','üèûÔ∏è','üåÖ','üåÑ','üå†','üéá','üéÜ','üåá','üåÜ','üèôÔ∏è','üåÉ','üåå','üåâ','üåÅ'],
            objects: ['‚åö','üì±','üì≤','üíª','‚å®Ô∏è','üñ•Ô∏è','üñ®Ô∏è','üñ±Ô∏è','üñ≤Ô∏è','üïπÔ∏è','üóúÔ∏è','üíΩ','üíæ','üíø','üìÄ','üìº','üì∑','üì∏','üìπ','üé•','üìΩÔ∏è','üéûÔ∏è','üìû','‚òéÔ∏è','üìü','üì†','üì∫','üìª','üéôÔ∏è','üéöÔ∏è','üéõÔ∏è','üß≠','‚è±Ô∏è','‚è≤Ô∏è','‚è∞','üï∞Ô∏è','‚åõ','‚è≥','üì°','üîã','üîå','üí°','üî¶','üïØÔ∏è','ü™î','üßØ','üõ¢Ô∏è','üí∏','üíµ','üí¥','üí∂','üí∑','üí∞','üí≥','üíé','‚öñÔ∏è','üß∞','üîß','üî®','‚öíÔ∏è','üõ†Ô∏è','‚õèÔ∏è','üî©','‚öôÔ∏è','üß±','‚õìÔ∏è','üß≤','üî´','üí£','üß®','ü™ì','üî™','üó°Ô∏è','‚öîÔ∏è','üõ°Ô∏è','üö¨','‚ö∞Ô∏è','‚ö±Ô∏è','üè∫','üîÆ','üìø','üßø','üíà','‚öóÔ∏è','üî≠','üî¨','üï≥Ô∏è','ü©π','ü©∫','üíä','üíâ','ü©∏','üß¨','ü¶†','üß´','üß™','üå°Ô∏è','üßπ','üß∫','üßª','üöΩ','üö∞','üöø','üõÅ','üõÄ','üßº','ü™í','üßΩ','üß¥','üõéÔ∏è','üîë','üóùÔ∏è','üö™','ü™ë','üõãÔ∏è','üõèÔ∏è','üñºÔ∏è','üõçÔ∏è','üß≥','üéí','ü©±','üëì','üï∂Ô∏è','ü•Ω','ü•æ','üëë','üé©','üéì','üß¢','‚õëÔ∏è','üìø','üíÑ','üíç','üíº'],
            symbols: ['‚ù§Ô∏è','üß°','üíõ','üíö','üíô','üíú','üñ§','ü§ç','ü§é','üíî','‚ù£Ô∏è','üíï','üíû','üíì','üíó','üíñ','üíò','üíù','üíü','‚òÆÔ∏è','‚úùÔ∏è','‚ò™Ô∏è','üïâÔ∏è','‚ò∏Ô∏è','‚ú°Ô∏è','üîØ','üïé','‚òØÔ∏è','‚ò¶Ô∏è','üõê','‚õé','‚ôà','‚ôâ','‚ôä','‚ôã','‚ôå','‚ôç','‚ôé','‚ôè','‚ôê','‚ôë','‚ôí','‚ôì','üÜî','‚öõÔ∏è','üâë','‚ò¢Ô∏è','‚ò£Ô∏è','üì¥','üì≥','üà∂','üàö','üà∏','üà∫','üà∑Ô∏è','‚ú¥Ô∏è','üÜö','üíÆ','üâê','„äôÔ∏è','„äóÔ∏è','üà¥','üàµ','üàπ','üà≤','üÖ∞Ô∏è','üÖ±Ô∏è','üÜé','üÜë','üÖæÔ∏è','üÜò','‚ùå','‚≠ï','üõë','‚õî','üìõ','üö´','üíØ','üí¢','‚ô®Ô∏è','üö∑','üöØ','üö≥','üö±','üîû','üìµ','üö≠','‚ùó','‚ùï','‚ùì','‚ùî','‚ÄºÔ∏è','‚ÅâÔ∏è','üîÖ','üîÜ','„ÄΩÔ∏è','‚ö†Ô∏è','üö∏','üî±','‚öúÔ∏è','üî∞','‚ôªÔ∏è','‚úÖ','üàØ','üíπ','‚ùáÔ∏è','‚ú≥Ô∏è','‚ùé','üåê','üí†','‚ìÇÔ∏è','üåÄ','üí§','üèß','üöæ','‚ôø','üÖøÔ∏è','üà≥','üàÇÔ∏è','üõÇ','üõÉ','üõÑ','üõÖ','üöπ','üö∫','üöº','üöª','üöÆ','üé¶','üì∂','üàÅ','üî£','‚ÑπÔ∏è','üî§','üî°','üî†','üÜñ','üÜó','üÜô','üÜí','üÜï','üÜì','0Ô∏è‚É£','1Ô∏è‚É£','2Ô∏è‚É£','3Ô∏è‚É£','4Ô∏è‚É£','5Ô∏è‚É£','6Ô∏è‚É£','7Ô∏è‚É£','8Ô∏è‚É£','9Ô∏è‚É£','üîü','üî¢','#Ô∏è‚É£','*Ô∏è‚É£','‚èèÔ∏è','‚ñ∂Ô∏è','‚è∏Ô∏è','‚èØÔ∏è','‚èπÔ∏è','‚è∫Ô∏è','‚è≠Ô∏è','‚èÆÔ∏è','‚è©','‚è™','‚è´','‚è¨','‚óÄÔ∏è','üîº','üîΩ','‚û°Ô∏è','‚¨ÖÔ∏è','‚¨ÜÔ∏è','‚¨áÔ∏è','‚ÜóÔ∏è','‚ÜòÔ∏è','‚ÜôÔ∏è','‚ÜñÔ∏è','‚ÜïÔ∏è','‚ÜîÔ∏è','‚Ü™Ô∏è','‚Ü©Ô∏è','‚§¥Ô∏è','‚§µÔ∏è','üîÄ','üîÅ','üîÇ','üîÑ','üîÉ','üéµ','üé∂','‚ûï','‚ûñ','‚ûó','‚úñÔ∏è','‚ôæÔ∏è','üí≤','üí±','‚Ñ¢Ô∏è','¬©Ô∏è','¬ÆÔ∏è','„Ä∞Ô∏è','‚û∞','‚ûø','üîö','üîô','üîõ','üîù','üîú','‚úîÔ∏è','‚òëÔ∏è','üîò','üî¥','üü†','üü°','üü¢','üîµ','üü£','‚ö´','‚ö™','üü§','üî∫','üîª','üî∏','üîπ','üî∂','üî∑','üî≥','üî≤','‚ñ™Ô∏è','‚ñ´Ô∏è','‚óæ','‚óΩ','‚óºÔ∏è','‚óªÔ∏è','üü•','üüß','üü®','üü©','üü¶','üü™','‚¨õ','‚¨ú','üü´','üîà','üîá','üîâ','üîä','üîî','üîï','üì£','üì¢','üí¨','üí≠','üóØÔ∏è','‚ô†Ô∏è','‚ô£Ô∏è','‚ô•Ô∏è','‚ô¶Ô∏è','üÉè','üé¥','üÄÑ','üïê','üïë','üïí','üïì','üïî','üïï','üïñ','üïó','üïò','üïô','üïö','üïõ','üïú','üïù','üïû','üïü','üï†','üï°','üï¢','üï£','üï§','üï•','üï¶','üïß'],
            flags: ['üèÅ','üö©','üéå','üè¥','üè≥Ô∏è','üè≥Ô∏è‚Äçüåà','üè≥Ô∏è‚Äç‚ößÔ∏è','üè¥‚Äç‚ò†Ô∏è','üá¶üá®','üá¶üá©','üá¶üá™','üá¶üá´','üá¶üá¨','üá¶üáÆ','üá¶üá±','üá¶üá≤','üá¶üá¥','üá¶üá∂','üá¶üá∑','üá¶üá∏','üá¶üáπ','üá¶üá∫','üá¶üáº','üá¶üáΩ','üá¶üáø','üáßüá¶','üáßüáß','üáßüá©','üáßüá™','üáßüá´','üáßüá¨','üáßüá≠','üáßüáÆ','üáßüáØ','üáßüá±','üáßüá≤','üáßüá≥','üáßüá¥','üáßüá∂','üáßüá∑','üáßüá∏','üáßüáπ','üáßüáª','üáßüáº','üáßüáæ','üáßüáø','üá®üá¶','üá®üá®','üá®üá©','üá®üá´','üá®üá¨','üá®üá≠','üá®üáÆ','üá®üá∞','üá®üá±','üá®üá≤','üá®üá≥','üá®üá¥','üá®üáµ','üá®üá∑','üá®üá∫','üá®üáª','üá®üáº','üá®üáΩ','üá®üáæ','üá®üáø','üá©üá™','üá©üá¨','üá©üáØ','üá©üá∞','üá©üá≤','üá©üá¥','üá©üáø','üá™üá¶','üá™üá®','üá™üá™','üá™üá¨','üá™üá≠','üá™üá∑','üá™üá∏','üá™üáπ','üá™üá∫','üá´üáÆ','üá´üáØ','üá´üá∞','üá´üá≤','üá´üá¥','üá´üá∑','üá¨üá¶','üá¨üáß','üá¨üá©','üá¨üá™','üá¨üá´','üá¨üá¨','üá¨üá≠','üá¨üáÆ','üá¨üá±','üá¨üá≤','üá¨üá≥','üá¨üáµ','üá¨üá∂','üá¨üá∑','üá¨üá∏','üá¨üáπ','üá¨üá∫','üá¨üáº','üá¨üáæ','üá≠üá∞','üá≠üá≤','üá≠üá≥','üá≠üá∑','üá≠üáπ','üá≠üá∫','üáÆüá®','üáÆüá©','üáÆüá™','üáÆüá±','üáÆüá≤','üáÆüá≥','üáÆüá¥','üáÆüá∂','üáÆüá∑','üáÆüá∏','üáÆüáπ','üáØüá™','üáØüá≤','üáØüá¥','üáØüáµ','üá∞üá™','üá∞üá¨','üá∞üá≠','üá∞üáÆ','üá∞üá≤','üá∞üá≥','üá∞üáµ','üá∞üá∑','üá∞üáº','üá∞üáæ','üá∞üáø','üá±üá¶','üá±üáß','üá±üá®','üá±üáÆ','üá±üá∞','üá±üá∑','üá±üá∏','üá±üáπ','üá±üá∫','üá±üáª','üá±üáæ','üá≤üá¶','üá≤üá®','üá≤üá©','üá≤üá™','üá≤üá´','üá≤üá¨','üá≤üá≠','üá≤üá∞','üá≤üá±','üá≤üá≤','üá≤üá≥','üá≤üá¥','üá≤üáµ','üá≤üá∂','üá≤üá∑','üá≤üá∏','üá≤üáπ','üá≤üá∫','üá≤üáª','üá≤üáº','üá≤üáΩ','üá≤üáæ','üá≤üáø','üá≥üá¶','üá≥üá®','üá≥üá™','üá≥üá´','üá≥üá¨','üá≥üáÆ','üá≥üá±','üá≥üá¥','üá≥üáµ','üá≥üá∑','üá≥üá∫','üá≥üáø','üá¥üá≤','üáµüá¶','üáµüá™','üáµüá´','üáµüá¨','üáµüá≠','üáµüá∞','üáµüá±','üáµüá≤','üáµüá≥','üáµüá∑','üáµüá∏','üáµüáπ','üáµüáº','üáµüáæ','üá∂üá¶','üá∑üá™','üá∑üá¥','üá∑üá∏','üá∑üá∫','üá∑üáº','üá∏üá¶','üá∏üáß','üá∏üá®','üá∏üá©','üá∏üá™','üá∏üá¨','üá∏üá≠','üá∏üáÆ','üá∏üáØ','üá∏üá∞','üá∏üá±','üá∏üá≤','üá∏üá≥','üá∏üá¥','üá∏üá∑','üá∏üá∏','üá∏üáπ','üá∏üáª','üá∏üáΩ','üá∏üáæ','üá∏üáø','üáπüá¶','üáπüá®','üáπüá©','üáπüá´','üáπüá¨','üáπüá≠','üáπüáØ','üáπüá∞','üáπüá±','üáπüá≤','üáπüá≥','üáπüá¥','üáπüá∑','üáπüáπ','üáπüáª','üáπüáº','üáπüáø','üá∫üá¶','üá∫üá¨','üá∫üá≤','üá∫üá≥','üá∫üá∏','üá∫üáæ','üá∫üáø','üáªüá¶','üáªüá®','üáªüá™','üáªüá¨','üáªüáÆ','üáªüá≥','üáªüá∫','üáºüá´','üáºüá∏','üáΩüá∞','üáæüá™','üáæüáπ','üáøüá¶','üáøüá≤','üáøüáº','üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø','üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø','üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø']
        };

        // Load recent emojis from localStorage
        function loadRecentEmojis() {
            const stored = localStorage.getItem('ngm_recent_emojis');
            if (stored) {
                try {
                    recentEmojis = JSON.parse(stored);
                } catch (e) {
                    recentEmojis = [];
                }
            }
        }

        // Save recent emojis to localStorage
        function saveRecentEmojis() {
            localStorage.setItem('ngm_recent_emojis', JSON.stringify(recentEmojis));
        }

        // Add emoji to recent
        function addToRecent(emoji) {
            // Remove if already exists
            recentEmojis = recentEmojis.filter(e => e !== emoji);
            // Add to beginning
            recentEmojis.unshift(emoji);
            // Keep only 25 most recent
            recentEmojis = recentEmojis.slice(0, 25);
            saveRecentEmojis();
        }

        // Check if user is at bottom of messages
        function checkIfAtBottom() {
            const messagesArea = document.getElementById('messagesArea');
            const threshold = 100; // pixels from bottom
            isUserAtBottom = (messagesArea.scrollHeight - messagesArea.scrollTop - messagesArea.clientHeight) < threshold;
            
            if (isUserAtBottom && unreadCount > 0) {
                // User scrolled to bottom - clear unread badge
                unreadCount = 0;
                hideUnreadBadge();
                markMessagesAsRead();
            }
        }

        // Show unread badge
        function showUnreadBadge() {
            const badge = document.getElementById('unreadBadge');
            const countEl = document.getElementById('unreadCount');
            const pluralEl = document.getElementById('unreadPlural');
            
            countEl.textContent = unreadCount;
            pluralEl.textContent = unreadCount > 1 ? 's' : '';
            badge.classList.add('show');
        }

        // Hide unread badge
        function hideUnreadBadge() {
            const badge = document.getElementById('unreadBadge');
            badge.classList.remove('show');
        }

        // Scroll to bottom and mark as read
        function scrollToBottomAndRead() {
            scrollToBottom();
            unreadCount = 0;
            hideUnreadBadge();
            markMessagesAsRead();
        }

        // Toggle emoji picker
        function toggleEmojiPicker() {
            const picker = document.getElementById('emojiPicker');
            const emojiBtn = document.getElementById('emojiBtn');
            const keyboardBtn = document.getElementById('keyboardBtn');
            const messagesArea = document.getElementById('messagesArea');
            const messageInput = document.getElementById('messageInput');
            const isShowing = picker.classList.contains('show');
            
            if (isShowing) {
                closeEmojiPicker();
            } else {
                // Blur the input to hide keyboard
                messageInput.blur();
                
                // Small delay to ensure keyboard is hidden
                setTimeout(() => {
                    picker.classList.add('show');
                    emojiBtn.classList.add('active');
                    keyboardBtn.classList.add('show');
                    messagesArea.classList.add('with-emoji-picker');
                    renderEmojis(currentEmojiCategory);
                    scrollToBottom();
                }, 100);
            }
        }

        // Close emoji picker
        function closeEmojiPicker() {
            const picker = document.getElementById('emojiPicker');
            const emojiBtn = document.getElementById('emojiBtn');
            const keyboardBtn = document.getElementById('keyboardBtn');
            const messagesArea = document.getElementById('messagesArea');
            
            picker.classList.remove('show');
            emojiBtn.classList.remove('active');
            keyboardBtn.classList.remove('show');
            messagesArea.classList.remove('with-emoji-picker');
            
            // Focus back on input to show keyboard
            document.getElementById('messageInput').focus();
        }

        // Switch emoji category
        function switchEmojiCategory(category) {
            currentEmojiCategory = category;
            
            // Update active button
            document.querySelectorAll('.emoji-category-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-category="${category}"]`).classList.add('active');
            
            // Render emojis for this category
            renderEmojis(category);
        }

        // Render emojis
        function renderEmojis(category) {
            const grid = document.getElementById('emojiGrid');
            let html = '';
            
            if (category === 'recent') {
                if (recentEmojis.length > 0) {
                    html += '<div class="emoji-section-title">Recent</div>';
                    html += '<div class="emoji-items">';
                    recentEmojis.forEach(emoji => {
                        html += `<button class="emoji-item" onclick="insertEmoji('${emoji}')">${emoji}</button>`;
                    });
                    html += '</div>';
                } else {
                    html += '<div style="padding: 40px; text-align: center; color: #9ca3af;">No recent emojis</div>';
                }
            } else {
                const emojis = emojiData[category] || [];
                html += '<div class="emoji-items">';
                emojis.forEach(emoji => {
                    html += `<button class="emoji-item" onclick="insertEmoji('${emoji}')">${emoji}</button>`;
                });
                html += '</div>';
            }
            
            grid.innerHTML = html;
        }

        // Search emoji
        function searchEmoji(query) {
            const grid = document.getElementById('emojiGrid');
            query = query.toLowerCase().trim();
            
            if (!query) {
                renderEmojis(currentEmojiCategory);
                return;
            }
            
            // Search in all categories
            let results = [];
            Object.values(emojiData).forEach(category => {
                results = results.concat(category);
            });
            
            // For now, just show all emojis when searching
            // In a real app, you'd have emoji names/keywords to search
            let html = '<div class="emoji-section-title">Search Results</div>';
            html += '<div class="emoji-items">';
            results.slice(0, 64).forEach(emoji => {
                html += `<button class="emoji-item" onclick="insertEmoji('${emoji}')">${emoji}</button>`;
            });
            html += '</div>';
            
            grid.innerHTML = html;
        }

        // Insert emoji into message input
        function insertEmoji(emoji) {
            const input = document.getElementById('messageInput');
            const start = input.selectionStart || 0;
            const end = input.selectionEnd || 0;
            const text = input.value;
            
            // Insert emoji at cursor position
            input.value = text.substring(0, start) + emoji + text.substring(end);
            
            // Move cursor after emoji
            const newPos = start + emoji.length;
            input.setSelectionRange(newPos, newPos);
            
            // Add to recent
            addToRecent(emoji);
            
            // Update send button state
            handleInput();
            
            // Don't close emoji picker or focus input - keep emoji picker open
        }

        // Close emoji picker when clicking outside
        document.addEventListener('click', function(e) {
            const picker = document.getElementById('emojiPicker');
            const emojiBtn = document.getElementById('emojiBtn');
            const keyboardBtn = document.getElementById('keyboardBtn');
            const messageInput = document.getElementById('messageInput');
            
            if (picker && picker.classList.contains('show')) {
                // Only close if clicking outside picker AND outside both buttons AND outside input
                if (!picker.contains(e.target) && 
                    !emojiBtn.contains(e.target) && 
                    !keyboardBtn.contains(e.target) &&
                    !messageInput.contains(e.target)) {
                    closeEmojiPicker();
                }
            }
        });

        // Handle back button behavior
        let backButtonPressCount = 0;
        let backButtonTimeout = null;

        function handleBackButton(e) {
            const picker = document.getElementById('emojiPicker');
            const messageInput = document.getElementById('messageInput');
            
            // Check if emoji picker is open or keyboard is focused
            const isEmojiPickerOpen = picker.classList.contains('show');
            const isInputFocused = document.activeElement === messageInput;
            
            if (isEmojiPickerOpen || isInputFocused) {
                e.preventDefault();
                
                if (isEmojiPickerOpen) {
                    closeEmojiPicker();
                    backButtonPressCount = 0;
                } else if (isInputFocused) {
                    messageInput.blur();
                    backButtonPressCount = 0;
                }
            } else {
                backButtonPressCount++;
                
                if (backButtonPressCount === 1) {
                    e.preventDefault();
                    
                    // Reset counter after 2 seconds
                    if (backButtonTimeout) clearTimeout(backButtonTimeout);
                    backButtonTimeout = setTimeout(() => {
                        backButtonPressCount = 0;
                    }, 2000);
                } else if (backButtonPressCount >= 2) {
                    // Allow navigation on second press
                    backButtonPressCount = 0;
                    window.location.href = 'ngm_main_chat.html';
                }
            }
        }

        // Add popstate listener for back button
        window.addEventListener('popstate', handleBackButton);
        
        // Push initial state
        history.pushState(null, null, location.href);

        const urlParams = new URLSearchParams(window.location.search);
        currentChatId = urlParams.get('chat_id');

        if (!currentChatId) {
            alert('No chat selected');
            window.location.href = 'ngm_main_chat.html';
        }

        async function checkAuth() {
            const { data: { user } } = await supabaseClient.auth.getUser();
            if (!user) {
                window.location.href = 'login.html';
                return null;
            }
            currentUser = user;
            return user;
        }

        function formatLastSeen(lastSeenStr, isOnline) {
            const lastSeen = new Date(lastSeenStr);
            const now = new Date();
            const diffMs = now - lastSeen;
            const diffSeconds = Math.floor(diffMs / 1000);
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (isOnline === true && diffSeconds <= 60) {
                return 'online';
            }
            
            if (diffMins < 1) return 'last seen just now';
            if (diffMins === 1) return 'last seen 1 min ago';
            if (diffMins < 60) return 'last seen ' + diffMins + ' min ago';
            if (diffHours === 1) return 'last seen 1 hour ago';
            if (diffHours < 24) return 'last seen ' + diffHours + ' hours ago';
            if (diffDays === 1) return 'last seen yesterday';
            if (diffDays < 7) return 'last seen ' + diffDays + ' days ago';
            return 'last seen ' + lastSeen.toLocaleDateString();
        }

        function updateUserStatus(userData, isBlocked) {
            let statusText = '';
            if (isBlocked) {
                statusText = 'last seen a long time ago';
            } else {
                statusText = formatLastSeen(userData.last_seen, userData.is_online);
            }
            
            const statusEl = document.getElementById('chatStatus');
            statusEl.textContent = statusText;
            statusEl.classList.remove('typing');
        }

        function showTypingIndicator(userName) {
            const statusEl = document.getElementById('chatStatus');
            statusEl.innerHTML = 'typing<span class="typing-dots"><span>.</span><span>.</span><span>.</span></span>';
            statusEl.classList.add('typing');
        }

        function hideTypingIndicator() {
            if (otherUserData) {
                updateUserStatus(otherUserData, isOtherUserBlocked);
            }
        }

        let statusSubscription = null;
        let otherUserData = null;
        let isOtherUserBlocked = false;
        let otherUserId = null;

        function setupTypingIndicator(userId) {
            otherUserId = userId;
            
            if (typingSubscription) {
                supabaseClient.removeChannel(typingSubscription);
            }

            // Clear any existing check interval
            if (typingCheckInterval) {
                clearInterval(typingCheckInterval);
            }

            typingSubscription = supabaseClient
                .channel('typing:' + currentChatId)
                .on('postgres_changes', {
                    event: '*',
                    schema: 'public',
                    table: 'ngm_typing_status',
                    filter: 'chat_id=eq.' + currentChatId
                }, payload => {
                    if (payload.new && payload.new.user_id === userId) {
                        if (payload.new.is_typing) {
                            showTypingIndicator();
                        } else {
                            hideTypingIndicator();
                        }
                    }
                })
                .subscribe();

            // Continuously check typing status every 2 seconds
            typingCheckInterval = setInterval(async () => {
                try {
                    const { data } = await supabaseClient
                        .from('ngm_typing_status')
                        .select('is_typing, last_typing_at')
                        .eq('chat_id', currentChatId)
                        .eq('user_id', userId)
                        .maybeSingle();

                    if (data && data.is_typing) {
                        // Check if typing was recent (within last 5 seconds)
                        const lastTyping = new Date(data.last_typing_at);
                        const now = new Date();
                        const diffSeconds = (now - lastTyping) / 1000;
                        
                        if (diffSeconds < 5) {
                            showTypingIndicator();
                        } else {
                            hideTypingIndicator();
                        }
                    } else {
                        hideTypingIndicator();
                    }
                } catch (error) {
                    console.error('Error checking typing status:', error);
                }
            }, 2000);
        }

        async function setTypingStatus(typing) {
            if (isTyping === typing) return;
            isTyping = typing;

            try {
                await supabaseClient
                    .from('ngm_typing_status')
                    .upsert({
                        chat_id: currentChatId,
                        user_id: currentUser.id,
                        is_typing: typing,
                        last_typing_at: new Date().toISOString()
                    }, {
                        onConflict: 'chat_id,user_id'
                    });
            } catch (error) {
                console.error('Error updating typing status:', error);
            }
        }

        function setupLiveStatusUpdates(userId) {
            if (statusSubscription) {
                supabaseClient.removeChannel(statusSubscription);
            }
            
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
            }

            statusSubscription = supabaseClient
                .channel('user-status:' + userId)
                .on('postgres_changes', {
                    event: 'UPDATE',
                    schema: 'public',
                    table: 'ngm_users',
                    filter: 'user_id=eq.' + userId
                }, payload => {
                    otherUserData = payload.new;
                    supabaseClient
                        .from('ngm_blocked_users')
                        .select('block_id')
                        .eq('user_id', userId)
                        .eq('blocked_user_id', currentUser.id)
                        .maybeSingle()
                        .then(({ data }) => {
                            isOtherUserBlocked = !!data;
                            updateUserStatus(otherUserData, isOtherUserBlocked);
                        });
                })
                .subscribe();
            
            statusUpdateInterval = setInterval(() => {
                if (otherUserData) {
                    updateUserStatus(otherUserData, isOtherUserBlocked);
                }
            }, 10000);
        }

        async function loadChatDetails() {
            try {
                const { data: chat, error: chatError } = await supabaseClient
                    .from('ngm_chats')
                    .select('*')
                    .eq('chat_id', currentChatId)
                    .single();

                if (chatError) throw chatError;

                currentChatData = chat;

                if (chat.chat_type === 'private' || chat.chat_type === 'personal') {
                    const otherUserId = chat.user1_id === currentUser.id ? chat.user2_id : chat.user1_id;
                    
                    const { data: userData, error: userError } = await supabaseClient
                        .from('ngm_users')
                        .select('full_name, username, profile_picture_url, is_online, last_seen')
                        .eq('user_id', otherUserId)
                        .single();

                    if (userError) throw userError;

                    otherUserData = userData;

                    const { data: contactData } = await supabaseClient
                        .from('ngm_contacts')
                        .select('contact_name')
                        .eq('user_id', currentUser.id)
                        .eq('contact_user_id', otherUserId)
                        .maybeSingle();

                    const { data: blockedData } = await supabaseClient
                        .from('ngm_blocked_users')
                        .select('block_id')
                        .eq('user_id', otherUserId)
                        .eq('blocked_user_id', currentUser.id)
                        .maybeSingle();

                    isOtherUserBlocked = !!blockedData;

                    const name = contactData?.contact_name || userData.full_name || userData.username || 'Unknown User';
                    document.getElementById('chatName').textContent = name;
                    
                    updateUserStatus(userData, isOtherUserBlocked);

                    if (userData.profile_picture_url) {
                        document.getElementById('chatAvatar').style.backgroundImage = "url('" + userData.profile_picture_url + "')";
                    } else {
                        document.getElementById('chatAvatar').textContent = name.charAt(0).toUpperCase();
                    }
                    
                    setupLiveStatusUpdates(otherUserId);
                    setupTypingIndicator(otherUserId);
                } else if (chat.chat_type === 'group') {
                    const { data: groupData } = await supabaseClient
                        .from('ngm_groups')
                        .select('group_name, group_picture_url')
                        .eq('chat_id', currentChatId)
                        .single();

                    const name = groupData?.group_name || 'Group Chat';
                    document.getElementById('chatName').textContent = name;
                    document.getElementById('chatStatus').textContent = 'Group';

                    if (groupData?.group_picture_url) {
                        document.getElementById('chatAvatar').style.backgroundImage = "url('" + groupData.group_picture_url + "')";
                    } else {
                        document.getElementById('chatAvatar').textContent = name.charAt(0).toUpperCase();
                    }

                    const { count } = await supabaseClient
                        .from('ngm_chat_participants')
                        .select('*', { count: 'exact', head: true })
                        .eq('chat_id', currentChatId)
                        .eq('is_active', true);

                    document.getElementById('chatStatus').textContent = count + ' members';
                } else if (chat.chat_type === 'channel') {
                    const { data: channelData } = await supabaseClient
                        .from('ngm_channels')
                        .select('channel_name, channel_picture_url, subscriber_count')
                        .eq('chat_id', currentChatId)
                        .single();

                    const name = channelData?.channel_name || 'Channel';
                    document.getElementById('chatName').textContent = name;
                    document.getElementById('chatStatus').textContent = (channelData?.subscriber_count || 0) + ' subscribers';

                    if (channelData?.channel_picture_url) {
                        document.getElementById('chatAvatar').style.backgroundImage = "url('" + channelData.channel_picture_url + "')";
                    } else {
                        document.getElementById('chatAvatar').textContent = name.charAt(0).toUpperCase();
                    }
                }
            } catch (error) {
                console.error('Error loading chat details:', error);
                document.getElementById('chatName').textContent = 'Error loading chat';
            }
        }

        async function loadMessages() {
            try {
                const { data: msgs, error } = await supabaseClient
                    .from('ngm_messages')
                    .select('*')
                    .eq('chat_id', currentChatId)
                    .eq('is_deleted', false)
                    .order('created_at', { ascending: true });

                if (error) throw error;

                messages = msgs || [];
                
                if (currentChatData && (currentChatData.chat_type === 'private' || currentChatData.chat_type === 'personal')) {
                    const otherUserId = currentChatData.user1_id === currentUser.id ? currentChatData.user2_id : currentChatData.user1_id;
                    
                    for (let msg of messages) {
                        if (msg.sender_id === currentUser.id) {
                            const { data: readStatus } = await supabaseClient
                                .from('ngm_message_status')
                                .select('status')
                                .eq('message_id', msg.message_id)
                                .eq('user_id', otherUserId)
                                .eq('status', 'read')
                                .maybeSingle();
                            
                            msg.has_been_read = !!readStatus;
                        }
                    }
                }
                
                const loadingEl = document.getElementById('loadingMessages');
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                }
                
                renderMessages();
                scrollToBottom();

                await markMessagesAsRead();

            } catch (error) {
                console.error('Error loading messages:', error);
                const loadingEl = document.getElementById('loadingMessages');
                if (loadingEl) {
                    loadingEl.innerHTML = '<p style="color: #ef4444;">Error loading messages</p>';
                }
            }
        }

        function getMessageTick(msg) {
            const singleTick = '<svg class="read-tick" width="16" height="15" viewBox="0 0 16 15" fill="#8696a0"><path d="M15.01 3.316l-.478-.372a.365.365 0 0 0-.51.063L8.666 9.879a.32.32 0 0 1-.484.033l-.358-.325a.319.319 0 0 0-.484.032l-.378.483a.418.418 0 0 0 .036.541l1.32 1.266c.143.14.361.125.484-.033l6.272-8.048a.366.366 0 0 0-.064-.512z"/></svg>';
            
            const doubleTick = '<svg class="read-tick" width="16" height="15" viewBox="0 0 16 15" fill="#8696a0"><path d="M15.01 3.316l-.478-.372a.365.365 0 0 0-.51.063L8.666 9.879a.32.32 0 0 1-.484.033l-.358-.325a.319.319 0 0 0-.484.032l-.378.483a.418.418 0 0 0 .036.541l1.32 1.266c.143.14.361.125.484-.033l6.272-8.048a.366.366 0 0 0-.064-.512zm-4.1 0l-.478-.372a.365.365 0 0 0-.51.063L4.566 9.879a.32.32 0 0 1-.484.033L1.891 7.769a.366.366 0 0 0-.515.006l-.423.433a.364.364 0 0 0 .006.514l3.258 3.185c.143.14.361.125.484-.033l6.272-8.048a.365.365 0 0 0-.063-.51z"/></svg>';
            
            const blueDoubleTick = '<svg class="read-tick" width="16" height="15" viewBox="0 0 16 15" fill="#53bdeb"><path d="M15.01 3.316l-.478-.372a.365.365 0 0 0-.51.063L8.666 9.879a.32.32 0 0 1-.484.033l-.358-.325a.319.319 0 0 0-.484.032l-.378.483a.418.418 0 0 0 .036.541l1.32 1.266c.143.14.361.125.484-.033l6.272-8.048a.366.366 0 0 0-.064-.512zm-4.1 0l-.478-.372a.365.365 0 0 0-.51.063L4.566 9.879a.32.32 0 0 1-.484.033L1.891 7.769a.366.366 0 0 0-.515.006l-.423.433a.364.364 0 0 0 .006.514l3.258 3.185c.143.14.361.125.484-.033l6.272-8.048a.365.365 0 0 0-.063-.51z"/></svg>';
            
            if (msg.has_been_read) {
                return blueDoubleTick;
            } else {
                return singleTick;
            }
        }

        function renderMessages() {
            const messagesArea = document.getElementById('messagesArea');
            
            if (!messages || messages.length === 0) {
                messagesArea.innerHTML = '<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #9ca3af;"><svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="margin-bottom: 16px; opacity: 0.5;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg><p style="font-size: 16px; margin-bottom: 8px;">No messages yet</p><p style="font-size: 14px;">Start the conversation!</p></div>';
                return;
            }
            
            messagesArea.innerHTML = messages.map(msg => {
                const isSent = msg.sender_id === currentUser.id;
                const time = new Date(msg.created_at).toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit' 
                });

                return '<div class="message ' + (isSent ? 'message-sent' : 'message-received') + '"><div class="message-content">' + msg.content + '</div><div class="message-time">' + time + (isSent ? getMessageTick(msg) : '') + '</div></div>';
            }).join('');
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            const picker = document.getElementById('emojiPicker');
            const isEmojiPickerOpen = picker.classList.contains('show');
            
            if (!message) return;

            setTypingStatus(false);
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }

            try {
                const { data: newMsg, error } = await supabaseClient
                    .from('ngm_messages')
                    .insert({
                        chat_id: currentChatId,
                        sender_id: currentUser.id,
                        message_type: 'text',
                        content: message
                    })
                    .select()
                    .single();

                if (error) throw error;

                await supabaseClient
                    .from('ngm_chats')
                    .update({ last_message_at: new Date().toISOString() })
                    .eq('chat_id', currentChatId);

                input.value = '';
                input.style.height = 'auto';
                document.getElementById('sendBtn').disabled = true;
                
                // Don't close emoji picker or blur input if emoji picker is open
                if (!isEmojiPickerOpen) {
                    input.blur();
                }

            } catch (error) {
                console.error('Error sending message:', error);
                alert('Failed to send message');
            }
        }

        async function markMessagesAsRead() {
            try {
                const unreadMsgIds = messages
                    .filter(msg => msg.sender_id !== currentUser.id)
                    .map(msg => msg.message_id);

                if (unreadMsgIds.length === 0) return;

                const { data: existingStatuses } = await supabaseClient
                    .from('ngm_message_status')
                    .select('message_id')
                    .in('message_id', unreadMsgIds)
                    .eq('user_id', currentUser.id);

                const existingMsgIds = new Set(existingStatuses?.map(s => s.message_id) || []);

                const newStatuses = unreadMsgIds
                    .filter(msgId => !existingMsgIds.has(msgId))
                    .map(msgId => ({
                        message_id: msgId,
                        user_id: currentUser.id,
                        status: 'read'
                    }));

                if (newStatuses.length > 0) {
                    await supabaseClient
                        .from('ngm_message_status')
                        .insert(newStatuses);
                }

                await supabaseClient
                    .from('ngm_chat_participants')
                    .update({ 
                        unread_count: 0,
                        last_read_message_id: messages[messages.length - 1]?.message_id 
                    })
                    .eq('chat_id', currentChatId)
                    .eq('user_id', currentUser.id);
            } catch (error) {
                console.error('Error marking messages as read:', error);
            }
        }

        function handleInput() {
            const input = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            
            input.style.height = 'auto';
            input.style.height = Math.min(input.scrollHeight, 100) + 'px';

            sendBtn.disabled = !input.value.trim();

            if (input.value.trim()) {
                setTypingStatus(true);

                if (typingTimeout) {
                    clearTimeout(typingTimeout);
                }

                typingTimeout = setTimeout(() => {
                    setTypingStatus(false);
                }, 3000);
            } else {
                setTypingStatus(false);
                if (typingTimeout) {
                    clearTimeout(typingTimeout);
                }
            }
        }
        
        // Prevent input focus from showing keyboard when emoji picker is open
        document.addEventListener('DOMContentLoaded', function() {
            const messageInput = document.getElementById('messageInput');
            
            messageInput.addEventListener('focus', function(e) {
                const picker = document.getElementById('emojiPicker');
                if (picker.classList.contains('show')) {
                    // If emoji picker is open, blur the input to prevent keyboard
                    e.preventDefault();
                    this.blur();
                }
            });
        });

        function scrollToBottom() {
            const messagesArea = document.getElementById('messagesArea');
            messagesArea.scrollTop = messagesArea.scrollHeight;
            isUserAtBottom = true;
        }

        function goBack() {
            window.location.href = 'ngm_main_chat.html';
        }

        function makeCall() {
            alert('Voice call feature coming soon!');
        }

        function openChatInfo() {
            alert('Chat info page coming soon!');
        }

        function setupRealtimeSubscription() {
            messagesSubscription = supabaseClient
                .channel('messages:' + currentChatId)
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'ngm_messages',
                    filter: 'chat_id=eq.' + currentChatId
                }, payload => {
                    console.log('New message received:', payload);
                    payload.new.has_been_read = false;
                    messages.push(payload.new);
                    renderMessages();
                    
                    // Check if message is from other user
                    if (payload.new.sender_id !== currentUser.id) {
                        // If user is not at bottom, show unread badge
                        if (!isUserAtBottom) {
                            unreadCount++;
                            showUnreadBadge();
                        } else {
                            // User is at bottom - auto scroll and mark as read
                            scrollToBottom();
                            markMessagesAsRead();
                        }
                    } else {
                        // Own message - always scroll to bottom
                        scrollToBottom();
                    }
                })
                .on('postgres_changes', {
                    event: 'UPDATE',
                    schema: 'public',
                    table: 'ngm_messages',
                    filter: 'chat_id=eq.' + currentChatId
                }, payload => {
                    console.log('Message updated:', payload);
                    const index = messages.findIndex(m => m.message_id === payload.new.message_id);
                    if (index !== -1) {
                        messages[index] = payload.new;
                        renderMessages();
                    }
                })
                .subscribe();
            
            supabaseClient
                .channel('message-status:' + currentChatId)
                .on('postgres_changes', {
                    event: '*',
                    schema: 'public',
                    table: 'ngm_message_status'
                }, async payload => {
                    console.log('Message status updated:', payload);
                    if (payload.new && payload.new.status === 'read') {
                        const msgIndex = messages.findIndex(m => m.message_id === payload.new.message_id);
                        if (msgIndex !== -1 && messages[msgIndex].sender_id === currentUser.id) {
                            messages[msgIndex].has_been_read = true;
                            renderMessages();
                        }
                    }
                })
                .subscribe();
        }

        window.addEventListener('DOMContentLoaded', async function() {
            initSupabase();
            loadRecentEmojis();
            const user = await checkAuth();
            if (user) {
                await supabaseClient
                    .from('ngm_users')
                    .update({ 
                        is_online: true,
                        last_seen: new Date().toISOString()
                    })
                    .eq('user_id', user.id);
                
                await loadChatDetails();
                await loadMessages();
                setupRealtimeSubscription();
                
                // Add scroll listener to detect when user scrolls up
                const messagesArea = document.getElementById('messagesArea');
                messagesArea.addEventListener('scroll', checkIfAtBottom);
                
                statusUpdateInterval = setInterval(async () => {
                    if (currentUser) {
                        await supabaseClient
                            .from('ngm_users')
                            .update({ 
                                last_seen: new Date().toISOString()
                            })
                            .eq('user_id', currentUser.id);
                    }
                }, 30000);
            }
        });

        window.addEventListener('beforeunload', () => {
            if (messagesSubscription) {
                supabaseClient.removeChannel(messagesSubscription);
            }
            if (statusSubscription) {
                supabaseClient.removeChannel(statusSubscription);
            }
            if (typingSubscription) {
                supabaseClient.removeChannel(typingSubscription);
            }
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
            }
            if (typingCheckInterval) {
                clearInterval(typingCheckInterval);
            }
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            
            if (currentUser && currentChatId) {
                setTypingStatus(false);
                supabaseClient
                    .from('ngm_users')
                    .update({ 
                        is_online: false,
                        last_seen: new Date().toISOString()
                    })
                    .eq('user_id', currentUser.id);
            }
        });

        document.addEventListener('visibilitychange', async () => {
            if (currentUser) {
                if (document.hidden) {
                    await supabaseClient
                        .from('ngm_users')
                        .update({ 
                            is_online: false,
                            last_seen: new Date().toISOString()
                        })
                        .eq('user_id', currentUser.id);
                } else {
                    await supabaseClient
                        .from('ngm_users')
                        .update({ 
                            is_online: true,
                            last_seen: new Date().toISOString()
                        })
                        .eq('user_id', currentUser.id);
                }
            }
        });
    </script>
</body>
</html>
